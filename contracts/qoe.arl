archetype qoe_dao

//-----------------------------------------------------------------------------
// Config
//-----------------------------------------------------------------------------

variable model_topo_cid      : string   = "QmSAHEgh5NozH8ALJk11WP4SdKSC1pQwnrFJ7wadUkz1gS"  
variable init_weights_cid    : string   = "QmayScJpjfU2FBosY2EJYz81D5Cw5H7dd4RnfrNFhF7qXZ"
variable quorum              : rational = 4/5          
variable super_majority      : rational = 2/3      
variable fraction_of_members : rational = 1/4
variable min_models          : nat      = 3


//-----------------------------------------------------------------------------
// Storage
//-----------------------------------------------------------------------------

variable current_round : nat = 1

asset member identified by addr {
  addr      : address;
  point     : nat = 1;
  withdrew  : nat = 0;
}

asset model identified by cid {
  cid           : string;
  nbsamples     : nat;
  owner         : address;
  round         : nat;
  accepted      : bool = false;
  accept_point  : nat;
  reject_point  : nat = 0;
  abstain_point : nat = 0;
  voter         : set<address>;
}

enum vote_value = 
| REJECT    //  0
| ACCEPT    //  1
| ABSTAIN   //  2

//-----------------------------------------------------------------------------
// Entrypoint
//-----------------------------------------------------------------------------

entry contribute(model_cid: string, number_of_samples: nat) {
  fail if {
    f: model.contains(model_cid) with "MODEL_ALREADY_EXIST";
    f0: model.select(the.owner = source and the.round = current_round).count() > 0 with "CONTRIBUTED_IN_CURRENT_ROUND";
  }
  effect {
    if not member.contains(source) then member.add({addr = source});

    model.add({
      cid           = model_cid;
      nbsamples     = number_of_samples;
      owner         = source;
      round         = current_round;
      accept_point  = member[source].point;
      voter         = [source] 
    });
  }
}

entry vote(model_cid: string, value: vote_value) {
  require {
    r   : model[model_cid].accepted = false or model[model_cid].round = current_round otherwise "POLL_ENDED";
    r0  : member.contains(source) otherwise "ONLY_MEMBER" 
  }
  fail if {
    f1  : model[model_cid].voter.contains(source) with "VOTED_ADDRESS"
  }
  effect {
    const voter_point = member[source].point;
    model[model_cid].voter.add(source);
    match value with
    | ACCEPT  ->  model[model_cid].accept_point   += voter_point
    | REJECT  ->  model[model_cid].reject_point   += voter_point
    | _       ->  model[model_cid].abstain_point  += voter_point
    end;

    if is_accepted(model_cid) then model[model_cid].accepted := true;

    // if enough accepted local models, finish round
    const num_accepted_models = model.select(the.round = current_round and the.accepted = true).count();
    const num_required_models = max(min_models, ceil(member.count() * fraction_of_members));

    if num_accepted_models >= num_required_models then begin
      const accepted_models = model.select(the.round = current_round and the.accepted = true);
      for model_id in accepted_models do
        const model_owner = model[model_id].owner;
        member[model_owner].point += 1;
      done;
    current_round += 1
    end
  }
}

entry withdraw(amount: nat) {
  require {
    r1: member.contains(source) otherwise "ONLY_MEMBER";
    r2: member[source].point >= member[source].withdrew + amount otherwise "NOT_ENOUGH_POINT";
  }
  effect {
    transfer (amount*1tz) to source;     // 1 point = 1 tez = 0.85$ = 20.000â‚«
    member[source].withdrew += amount;
  }
}

//-----------------------------------------------------------------------------
// Utils
//-----------------------------------------------------------------------------

function participation_rate(model_cid: string) : rational {
  const participation : nat = model[model_cid].accept_point + model[model_cid].reject_point + model[model_cid].abstain_point;
  const total         : nat = member.sum(point);
  return (participation / total)
}

function accept_rate(model_cid: string) : rational {
  return (model[model_cid].accept_point / (model[model_cid].accept_point + model[model_cid].reject_point))
}

function is_accepted(model_cid: string) : bool {
  const p_rate = participation_rate(model_cid);
  if p_rate < quorum then 
    return false
  else begin
    const a_rate = accept_rate(model_cid);
    return (a_rate >= super_majority)
  end
}
